# Toolchain SpeechRecorder — MAUS — EMU-SDMS

Most phonetic research projects involve this workflow:

1. Record speech
1. Annotate speech using automatic tools
1. Check and correct the generated annotations by hand
1. Analyze speech (connecting the primary data with annotations and derived signals)

The EMU Speech Database Management System is focused on steps 3 and 4 of this workflow. For the first two steps, it can very usefully be complemented by two other tools: [SpeechRecorder](http://www.speechrecorder.org/) and MAUS (or, more broadly speaking — and more correctly, for that matter — the [BAS Web Services](https://clarin.phonetik.uni-muenchen.de/BASWebServices)). This chapter introduces how the tools can be combined — in a systematic way, with as little fuss as possible.

## What do SpeechRecorder and MAUS do?

“SpeechRecorder is a platform independent audio recording software customized to the requirements of speech recordings” (http://www.speechrecorder.org/). To this end, SpeechRecorder lets you define prompts that participants will read (or otherwise react to) while you are recording them. At the end of a session, instead of one large recording of the whole session, you have a set of smaller audio recordings, each one representing a single prompt.

MAUS (Munich AUtomatic Segmentation) processes audio recordings with corresponding orthographic transcriptions, and outputs (1) a corresponding phonetic transcription and (2) a segmentation of the signal into individual speech sounds. As such, MAUS is a part of the [BAS Web Services](https://clarin.phonetik.uni-muenchen.de/BASWebServices). ^[Strictly speaking, MAUS is used in conjunction with G2P and possibly Chunker to achieve this result. The whole package is often referred to as MAUS, however.]

## Different types of prompts

Prompts are very often sentences that participants read out aloud (producing *read speech*). However, this need not be the case. Prompts may as well be, for example, images that participants have to name or describe, or written questions that participants answer.

In terms of processing, *read speech* has the advantage that the researcher already has orthographic transcriptions of all recordings, because the prompts *are* the transcriptions (this neglects hesitations, misread utterances, etc.).

For all cases besides read speech, transcriptions have to be prepared. For read speech, when hesitations etc. need to be considered, the existing transcriptions need to be corrected (per token). For the time being, this is out of the scope of this book.^[It will be covered, at a later time, in this or a separate chapter.]

## Combining the tools

The order of the processing steps is unchangeable: The files have to be recorded first, then annotated and then analyzed.

However, there are different ways of passing data around between the tools. For example SpeechRecorder might *export* files into emuDB format or the EMU-SDMS might *import* files stored in SpeechRecorder’s format. After all, they are separate tools and can be used individually (although the combination makes great sense).

Moreover, sometimes a database grows, and some new files are recorded while others have already been annotated or analyzed (which challenges the “unchangeable order of processing steps”).

We can see now that we have to convert our data between different formats. We want to benefit from all tools but keep the conversion work down to a minimum. In this section, we explain the (currently) best way to do this. We will import SpeechRecorder’s recordings and prompts into the EMU-SDMS and then use emuR to send the data to MAUS and other BAS Web Services.

### Importing recordings and transcriptions into Emu

#### Using the import_speechRecorder() function

The ```import_speechRecorder()``` function is in the making, but unfortunately not finished yet. We therefore have to resort to the second-best way of importing SpeechRecorder’s results into Emu:

#### Using intermediary text files

SpeechRecorder, per default, saves one .wav file for each prompt. With additional settings, it will save a .txt file containing the corresponding prompt along with each .wav file. This is great because it is exactly what MAUS needs as its input.

The following options must be configured *before recordings are made*. Note that parts of SpeechRecorder’s user interface are in German:

- Under “Projekt / Einstellungen... / Annotation”:
    - Under “Persist”, tick the checkbox that says “Simple text loader writer for annotation template for MAUS processing”
    - Under “Auto annotation”, tick the checkbox that says “Prompt template auto annotator” (note that the two checkboxes are very similar. Make sure to tick the right one.)
- In your script:
    - If you edit the XML file directly: Make sure each of your ```<mediaitem>``` elements has the attribute ```annotationTemplate="true"```
    - If you use the integrated script editor: Make sure to tick the checkbox “Use as annotation template” for *every recording*.

Now, after your recording session, you will have audio and text files. In emuR, this combination is called a *txt collection*. We will thus use the function ```convert_txtCollection```, to import SpeechRecorder’s files into Emu’s format. In the following example, we will use the sample txt collection included with the emuR package.

```{r results='hide', message=F, warning=F}
# Load the emuR package
library(emuR)

# Create demo data in directory provided by tempdir()
create_emuRdemoData(dir = tempdir())

# Import the sample txt collection.
# When used with real data, sourceDir should point to the RECS directory of your
# SpeechRecorder project.
convert_txtCollection(dbName = "myEmuDatabase",
                      sourceDir = file.path(tempdir(), "emuR_demoData", "txt_collection"),
                      targetDir = tempdir())

dbHandle = load_emuDB(file.path(tempdir(), "myEmuDatabase_emuDB"))
```

Now, you have an Emu database. You can inspect it using

```{r results='hide'}
summary(dbHandle)
```

or

```{r eval=F}
serve(dbHandle)
```

The database contains all our recordings, and exactly one type of annotation: orthographic transcription. No phonetic transcription, no segmentation. The next section will cover that.

### Feeding the data into MAUS

The .wav and .txt files could have been uploaded on the [BAS web site](https://clarin.phonetik.uni-muenchen.de/BASWebServices/#!/services/Pipeline), but we will do it using emuR. This is generally less error-prone and requires less manual work. Moreover, since it is a scripted way of doing things, we can reproduce it reliably.

To process the data, we make use of several of emuR’s functions called ```runBASwebservice_...```. They will upload the data to WebMAUS and accompanying services and save the results directly inside your existing emuDB (this of course takes some time, depending on the size of your database and the speed of your internet connection).

```{r eval=FALSE}
runBASwebservice_g2pForTokenization(handle = dbHandle,
                                    language = "eng-US",
                                    transcriptionAttributeDefinitionName = "transcription",
                                    orthoAttributeDefinitionName = "Word")

runBASwebservice_g2pForPronunciation(handle = dbHandle,
                                     language = "eng-US",
                                     orthoAttributeDefinitionName = "Word",
                                     canoAttributeDefinitionName = "Canonical")

runBASwebservice_maus(handle = dbHandle,
                      language = "eng-US",
                      canoAttributeDefinitionName = "Canonical",
                      mausAttributeDefinitionName = "Phonetic")
```

When the services are finished, we can use

```{r eval=F}
serve(db)
```

to inspect the database with the new annotations. This time, it includes segmentation into words and phonemes, canonical phonetic transcription and realized phonetic transcription.

This chapter described the current best practice of combining SpeechRecorder, MAUS and the EMU-SDMS to fit a typical phonetic project workflow.

```{r echo=FALSE, results='hide', message=FALSE}
# clean up emuR_demoData
unlink(file.path(tempdir(), "emuR_demoData"), recursive = TRUE)
