# The query system
<!-- \chapter{The query system} -->
<!-- \label{chap:querysys} -->

<!-- \begin{figure}[hpt] -->
<!-- \centering -->
<!--   % \includegraphics[scale=0.25]{pics/EMU-webAppEmu_query.pdf} -->
<!--   \input{pics/EMU-webAppEmu_query} -->
<!-- \end{figure} -->

<!-- This chapter describes the newly implemented query system of the \texttt{emuR} package. When developing the new \texttt{emuR} package it was essential that it had a query mechanism allowing users to query a database's annotations in a simple manner. The \acf{eql} of the \ac{emu-sdms} arose out of years of developing and improving upon the query language of the legacy system \citep[e.g.,][]{cassidy:sc2001a,harrington:2010a,john:2012a}. As a result, today we have an expressive, powerful, yet simple to learn and domain-specific query language. The \ac{eql} defines a user interface by allowing the user to formulate a formal language expression in the form of a query string. The evaluation of a query string results in a set of annotation items or, alternatively, a sequence of items of a single annotation level in the \texttt{emuDB} from which time information, if applicable (see Section \ref{subsec:query_deducingTime}), has been deduced from the time-bearing sub-level. An example of this is a simple query that extracts all strong syllables (i.e., syllable annotation items containing the label \textit{S} on the \textit{Syllable} level) from a set of hierarchical annotations (see Figure \ref{fig:amongstHier} for an example of a hierarchical annotation). The respective \ac{eql} query string \texttt{"Syllable == S"} results in a set of segments containing the annotation label \textit{S}. Due to the temporal inclusion constraint of the domination relationship, the start and end times of the queried segments are derived from the respective items of the \textit{Phonetic} level (i.e., the \textit{m} and \textit{H} nodes in Figure \ref{fig:amongstHier}), as this is the time-bearing sub-level. The \ac{eql} described here allows users to query the complex hierarchical annotation structures in their entirety as they are described in Chapter \ref{chap:annot_struct_mod}. -->

<!-- \begin{figure}[hpt] -->
<!-- \centering -->
<!--   \input{pics/amongstHier} -->
<!--   \caption{Simple partial hierarchy of an annotation of the word \textit{amongst} in the \textit{msajc003} bundle in the \textit{ae} demo \texttt{emuDB}.} -->
<!--   \label{fig:amongstHier} -->
<!-- \end{figure} -->

<!-- R Example \ref{rexample:query_loadDemoData} shows how to create the demo data that is provided by the \texttt{emuR} package followed by loading an example \texttt{emuDB} called \textit{ae} into the current R session. This database will be used in all the examples throughout this chapter. -->

<!-- <<rexample:query_loadDemoData, rexample=TRUE, results='hide', message=FALSE>>= -->
<!-- # load package -->
<!-- library(emuR) -->

<!-- # create demo data in directory  -->
<!-- # provided by tempdir() -->
<!-- create_emuRdemoData(dir = tempdir()) -->

<!-- # create path to demo database -->
<!-- path2ae = file.path(tempdir(), "emuR_demoData", "ae_emuDB") -->

<!-- # load database -->
<!-- ae = load_emuDB(path2ae, verbose = F) -->
<!-- @ -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- \section{\texttt{emuRsegs}: The resulting object of a query} -->
<!-- \label{sec:query_emuRsegs} -->

<!-- In \texttt{emuR} the result of a query or requery (see Section \ref{subsec:requery}) is a pre-specified object which is a superclass of the common \texttt{data.frame}. R Example \ref{rexample:emuRsegs} shows the result of a slightly expanded version of the above query (\texttt{"Syllable == S"}), which additionally uses the dominates operator (i.e., the \texttt{\textasciicircum} operator; for further information see Section \ref{subsubsec:query_dominationQueries}) to reduce the queried annotations to the partial hierarchy depicted in Figure \ref{fig:amongstHier} in the \textit{ae} demo \texttt{emuDB}. In this example, the classes of the resulting object including its printed output are displayed. The class vector of a resulting \texttt{emuRsegs} object also contains the legacy EMU system's \texttt{emusegs} class, which indicates that this object is fully backwards compatible with the legacy class and the methods available for it \citep[see][for details]{harrington:2010a}. The printed output provides information about which database was queried and what the query was as well as information about the labels, start and end times (in milliseconds), session, bundle, level and type information. The call to \texttt{colnames()} shows that the resulting object has additional columns, which are ignored by the \texttt{print()} function. This somewhat hidden information is used to store information about what the exact items or sequence of items were retrieved from the \texttt{emuDB}. This information is needed to know which items to start from in a requery (see Section \ref{subsec:requery}) and is also the reason why an \texttt{emuRsegs} object should be viewed as a reference of sequences of annotation items that belong to a single level in all annotation files of an \texttt{emuDB}. -->

<!-- <<rexample:emuRsegs, rexample=TRUE>>= -->
<!-- # query database -->
<!-- sl = query(ae, "[Syllable == S ^ Text == amongst]") -->

<!-- # show class vector -->
<!-- class(sl)  -->

<!-- # show sl object -->
<!-- sl -->

<!-- # show all (incl. hidden) column names -->
<!-- colnames(sl)  -->
<!-- @ -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- \section{\texttt{EQL}: The EMU Query Language version 2} -->

<!-- The \ac{eql} user interface was retained from the legacy system because it was sufficiently flexible and expressive enough to meet the query needs in most types of speech science research. The \ac{eql} parser implemented in \texttt{emuR} is based on the \ac{ebnf} \citep{garshol:2003a} formal language definition of \cite{john:2012a}, which defines the symbols and the relationship of those symbols to each other on which this language is built (see adapted version of entire \ac{ebnf} in Appendix \ref{app_chap:EQL_EBNF}). Here we will describe the various terms and components that comprise the slightly adapted version 2 of the \ac{eql}. It is worth noting that the new query mechanism uses a relational back-end to handle the various query operations (see Chapter \ref{chap:querysys_impl} for details). This means that expert users, who are proficient in \ac{sql} may also query this relational back-end directly. However, we feel the \ac{eql} provides a simple abstraction layer which is sufficient for most speech and spoken language research. -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- \subsection{Simple queries} -->

<!-- The most basic form of an \ac{eql} query is a simple equality, inequality, matching or non-matching query, two of which are displayed in R Example \ref{rexample:simpleq}. The syntax of a simple query term is \texttt{[L OPERATOR A]}, where \texttt{L} specifies a level (or alternatively the name of a parallel attribute definition); \texttt{OPERATOR} is one of \texttt{==} (equality), \texttt{!$=$} (inequality), \texttt{=\textasciitilde{}} (matching) or \texttt{!\textasciitilde{}} (non-matching); and \texttt{A} is an expression specifying the labels of the annotation items of \texttt{L} \footnote{The examples and syntax descriptions used in this chapter have been adapted from examples by \cite{cassidy:sc2001a} and \cite{harrington:2002aa} and were largely extracted from the \texttt{EQL} vignette of the \texttt{emuR} package. All of the examples were adapted to work with the supplied \textit{ae} \texttt{emuDB}.}. The second query in R Example \ref{rexample:simpleq} queries an event level. The result of querying an event level contains the same information as that of a segment level query except that the derived end times have the value zero. -->

<!-- <<rexample:simpleq, rexample=TRUE>>= -->
<!-- # query all annotation items containing  -->
<!-- # the label "m" on the "Phonetic" level -->
<!-- sl = query(ae, "Phonetic == m") -->

<!-- # query all items NOT containing the  -->
<!-- # label "H*" on the "Tone" level -->
<!-- sl = query(ae, "Tone != H*") -->

<!-- # show first entry of sl -->
<!-- head(sl, n = 1)  -->
<!-- @ -->

<!-- R Example \ref{rexample:simpleq} queries two levels that contain time information: a segment level and an event level. As described in Chapter \ref{chap:annot_struct_mod}, annotations in the \ac{emu-sdms} may also contain levels that do not contain time information. R Example \ref{rexample:simpleq_deduceTime} shows a query that queries annotation items on a level that does not contain time information (the \textit{Syllable} level) to show that the result contains deduced time information from the time-bearing sub-level. -->

<!-- <<rexample:simpleq_deduceTime, rexample=TRUE>>= -->
<!-- # query all annotation items containing  -->
<!-- # the label S on the Syllable level -->
<!-- sl = query(ae, "Syllable == S") -->

<!-- # show first entry of sl -->
<!-- head(sl, n = 1) -->
<!-- @ -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- \subsubsection{Queries using regular expressions} -->

<!-- The slightly expanded version 2 of the \ac{eql}, which comes with the \texttt{emuR} package, introduces regular expression operators (\texttt{=\textasciitilde{}} and \texttt{!\textasciitilde{}}). These allow users to formulate regular expressions for more expressive and precise pattern matching of annotations. A minimal set of examples displaying the new regular expression operators is shown in Table \ref{table:eqlExamples}. -->

<!-- \begin{table}[ht!] -->
<!-- \centering -->
<!-- \small -->
<!-- \begin{tabularx}{\textwidth}{lX} -->
<!-- \hline -->
<!-- Query & Function \\ -->
<!-- \hline -->
<!-- \texttt{"Phonetic =\textasciitilde{} '[AIOUEV]'"} & A disjunction of annotations using a RegEx character class \\ -->
<!-- \texttt{"Word =\textasciitilde{} a.*"} & All words beginning with \textit{a}\\ -->
<!-- \texttt{"Word !\textasciitilde{} .*st"} & All words not ending in \textit{st}\\ -->
<!-- \texttt{"[Phonetic == n \textasciicircum{} \#Syllable =\textasciitilde{} .*]"} & All syllables that dominate an \textit{n} segment of the Phonetic level\\ -->

<!-- \end{tabularx} -->
<!-- \caption{EQL V2: examples of simple and complex query strings using RegEx operators including their function descriptions.} -->
<!-- \label{table:eqlExamples} -->
<!-- \end{table} -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- \subsection{Combining simple queries} -->

<!-- The \ac{eql} contains three operators that can be used to combine the simple query terms described above as well as position queries which we will describe below. These three operators are the sequence operator, \texttt{-$>$}; the conjunction operator, \texttt{\&}; and the domination operator, \texttt{\textasciicircum}, which is used to perform hierarchical queries. These three types of queries are described below. To start with, we describe the two types of queries that query more complex annotation structures on the same level (sequence and conjunction queries). This is followed by a description of domination queries that query hierarchically linked annotation structures, sometimes spanning multiple annotation levels. -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- \subsubsection{Sequence queries} -->

<!-- The syntax of a query string using the \texttt{-$>$} sequence operator is \texttt{[L == A -$>$ L == B]} where annotation item \texttt{A} on level \texttt{L} precedes item \texttt{B} on level \texttt{L}. For a sequence query to work, both arguments must be on the same level. Alternatively parallel attribute definitions of the same level may also be chosen (see Chapter \ref{chap:annot_struct_mod} for further details). An example of a query string using the sequence operator is displayed in R Example \ref{rexample:seqq}. All rows in the resulting segment list have the start time of \textit{@}, the end time of \textit{n} and their labels are \textit{@-$>$n}, where the \textit{-$>$} substring denotes the sequence. -->

<!-- <<rexample:seqq, rexample=TRUE>>= -->
<!-- # query all sequences of items on the "Phonetic" level  -->
<!-- # in which an item containing the label "@" is followed by  -->
<!-- # an item containing the label "n" -->
<!-- sl = query(ae, "[Phonetic == @ -> Phonetic == n]") -->

<!-- # show first entry of sl -->
<!-- head(sl, n = 1)  -->
<!-- @ -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- \subsubsection{Result modifier} -->

<!-- Because users are often interested in just one element of a compound query such as sequence queries (e.g., the \textit{@}s in a \textit{@-$>$n} sequences), the \ac{eql} offers a so-called result modifier symbol, \texttt{\#}. This symbol may be placed in front of any simple query component of a multi component query as depicted in R Example \ref{rexample:resultmod}. Placing the hashtag in front of either the left or the right simple query term will result in segment lists that contains only the annotation items of the simple query term that have the hashtag in front of it. Only one result modifier may be used per query. -->

<!-- <<rexample:resultmod, rexample=TRUE>>= -->
<!-- # query the "@"s in "@->n" sequences -->
<!-- sl = query(ae, "[#Phonetic == @ -> Phonetic == n]") -->

<!-- # show first entry of sl -->
<!-- head(sl, n = 1)  -->

<!-- # query the "n"s in a "@->n" sequences -->
<!-- sl = query(ae, "[Phonetic == @ -> #Phonetic == n]") -->

<!-- # show first entry of sl -->
<!-- head(sl, n = 1)  -->
<!-- @ -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- \subsubsection{Conjunction queries} -->

<!-- The syntax of a query string using the conjunction operator can schematically be written as: \texttt{[L\_a1 == A \& L\_a2 == B \& L\_a3 == C \& L\_a4 == D \& ... \& L\_an == N]}, where annotation items on level \texttt{L} have the label \texttt{A} and also have the parallel labels \texttt{B}, \texttt{C}, \texttt{D}, ..., \texttt{N} (see Chapter \ref{chap:annot_struct_mod} for more information about parallel labels). By analogy with the sequence operator, all simple query statements must refer to the same level (i.e., only parallel attributes definitions of the same level indicated by the \texttt{a1 - an} may to be chosen). Hence, the conjunction operator is used to combine query conditions on the same level. Using the conjunction operator is useful for two reasons: -->

<!-- \begin{itemize} -->
<!--   \item It combines different attributes of the same level: \texttt{[Text == always \& Accent == S]} where \textit{Text} and \textit{Accent} are additional attributes of level \textit{Word}; and -->
<!--   \item It combines a simple query with a function query (see Position Queries Section \ref{subsec:query_positionQueries}): \texttt{[Phonetic == l \& Start(Word, Phonetic) == 1]}. -->
<!-- \end{itemize} -->

<!-- An example of a query string using the conjunction operator is displayed in R Example \ref{rexample:conjq}. -->

<!-- <<rexample:conjq, rexample=TRUE>>= -->
<!-- # query all words with the orthographic transcription "always"  -->
<!-- # that also have a strong word accent ("S")  -->
<!-- query(ae, "[Text == always & Accent == S]") -->
<!-- @ -->

<!-- R Example \ref{rexample:conjq} does not make use of the result modifier symbol. However, only the annotation items of the left simple query term (\texttt{Text == always}) are returned. This behavior is true for all \ac{eql} operators that combine simple query terms except for the sequence operator. As it is more explicit to use the result modifier to express the desired result, we recommend using the result modifier where possible. The more explicit variant of the above query which yields the same result is \texttt{"[\#Text == always \& Word == C]"}. -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- \subsubsection{Domination/hierarchical queries} -->
<!-- \label{subsubsec:query_dominationQueries} -->

<!-- Compared to sequence and conjunction queries, a domination query using the operator \texttt{\textasciicircum} is not bound to a single level. Instead, it allows users to query annotation items that are directly or indirectly linked over one or more levels. Queries using the domination operator are often referred to as hierarchical queries as they provide the ability to query the hierarchical annotations in a vertical or inter-level manner. Figure \ref{fig:amongstHierDomintation} shows the same partial hierarchy as Figure \ref{fig:amongstHier} but highlights the annotational items that are dominated by the strong syllable (\textit{S}) of the \textit{Syllable} level. Such linked hierarchical sub-structures can be queried using hierarchical/domination queries. -->

<!-- \begin{figure}[hpt] -->
<!-- \centering -->
<!--   \input{pics/amongstHierDomination} -->
<!--   \caption{Partial hierarchy depicting all annotation items that are dominated by the strong syllable (\textit{S}) of the \textit{Syllable} level (inside dashed box). Items marked \textcolor{three_color_c1}{green} belong to the \textcolor{three_color_c1}{\textit{Phoneme}} level, items marked \textcolor{three_color_c2}{orange} belong to the \textcolor{three_color_c2}{\textit{Phonetic}} level and the \textcolor{three_color_c3}{purple} dashed box indicates the set of items that are dominated by \textit{S}.} -->
<!--   \label{fig:amongstHierDomintation} -->
<!-- \end{figure} -->

<!-- A schematic representation of a simple domination query string that retrieves all annotation items \texttt{A} of level \texttt{L1} that are dominated by items \texttt{B} in level \texttt{L2} (i.e., items that are directly or indirectly linked) is \texttt{[L1 == A \textasciicircum{} L2 == B]}. Although the domination relationship is directed the domination operator is not. This means that either items in \texttt{L1} dominate items in \texttt{L2} or items in \texttt{L2} dominate items in \texttt{L1}. Note that link definitions that specify the validity of the domination have to be present in the \texttt{emuDB} configuration for this to work (see Chapter \ref{chap:emuDB} for details). An example of a query string using the domination operator is displayed in R Example \ref{rexample:domq}. -->

<!-- <<rexample:domq, rexample=TRUE>>= -->
<!-- # query all "p" phoneme items that belong   -->
<!-- # to / are dominated by a strong syllable ("S") -->
<!-- sl = query(ae, "[Phoneme == p ^ Syllable == S]") -->

<!-- # show first entry of sl -->
<!-- head(sl, n = 1) -->
<!-- @ -->

<!-- As with the conjunction query, if no result modifier is present, a dominates query returns the annotation items of the left simple query term. Hence, the more explicit variant of the above query is \texttt{"[\#Phoneme == p \textasciicircum{} Syllable == S]"}. -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- \subsection{Position queries} -->
<!-- \label{subsec:query_positionQueries} -->

<!-- The \ac{eql} has three function terms that specify where in a domination relationship a child level annotation item is allowed to occur. The three function terms are \texttt{Start()}, \texttt{End()} and \texttt{Medial()}. A schematic representation of a query string representing a simple usage of the \texttt{Start()}, \texttt{End()} and \texttt{Medial()} function would be: \texttt{POSFCT(L1, L2) == TRUE}. In this representation \texttt{POSFCT} is a placeholder for one of the three functions, at which level \texttt{L1} must dominate level \texttt{L2}. Where \texttt{L1} does indeed dominate \texttt{L2}, the corresponding item from level \texttt{L2} is returned. If the expression is set to \texttt{FALSE} (i.e., \texttt{POSFCT(L1, L2) == FALSE}), all the items that do not match the condition of \texttt{L2} are returned. An illustration of what is returned by each of the position functions depending on if they are set to \texttt{TRUE} or \texttt{FALSE} is depicted in Figure \ref{fig:query_positionSimple}, while R Example \ref{rexample:posq} shows an example query using a position query term. -->


<!-- \begin{figure}[hpt] -->
<!-- \centering -->
<!--   \input{pics/positionSimple} -->
<!--   \caption{Illustration of what is returned by the \texttt{Start()}, \texttt{Medial()} and \texttt{End()} functions depending if they are set to \textbf{A:} \textcolor{three_color_c1}{\texttt{TRUE}} (green) or \textbf{B:} \textcolor{three_color_c2}{\texttt{FALSE}} (orange).} -->
<!--   \label{fig:query_positionSimple} -->
<!-- \end{figure} -->

<!-- <<rexample:posq, rexample=TRUE>>= -->
<!-- # query all phoneme items that occur -->
<!-- # at the start of a syllable -->
<!-- sl = query(ae, "[Start(Syllable, Phoneme) == TRUE]") -->

<!-- # show first entry of sl -->
<!-- head(sl, n = 1)  -->
<!-- @ -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- \subsection{Count queries} -->
<!-- \label{subsec:query_countQueries} -->

<!-- A further query component of the \ac{eql} are so-called count queries. They allow the user to specify how many child nodes a parent annotation item is allowed to have. Figure \ref{fig:query_amongstHierCount} displays two syllables, one containing one phoneme and one phonetic annotation item, the other containing five phoneme and six phonetic items. Using \ac{eql}'s \texttt{Num()} function it is possible to specify which of the two syllables should be retrieved, depending on the number of phonemic or phonetic elements to which it is directly or indirectly linked. R Example \ref{rexample:query_countQuery} shows a query that queries all syllables that contain five phonemes. -->

<!-- \begin{figure}[hpt] -->
<!-- \centering -->
<!--   \input{pics/amongstHierCount} -->
<!--   \caption{Partial hierarchy depicting a \textit{Syllable} containing one \textit{Phoneme} and  \textit{Phonetic} item (green) and a \textit{Syllable} containing five \textit{Phoneme} and six \textit{Phonetic} items (orange).} -->
<!--   \label{fig:query_amongstHierCount} -->
<!-- \end{figure} -->


<!-- A schematic representation of a query string utilizing the count mechanism would be \texttt{[Num(L1, L2) == N]}, where \texttt{L1} contains \texttt{N} annotation items in \texttt{L2}. For this type of query to work \texttt{L1} has to dominate \texttt{L2} (i.e., be a parent level to \texttt{L2}). As the query matches a number (\texttt{N}), it is also possible to use the operators \texttt{>} (more than), \texttt{<} (less than) and \texttt{!=} (not equal to). The resulting segment list contains items of \texttt{L1}. -->

<!-- <<rexample:query_countQuery, rexample=TRUE>>= -->
<!-- # retrieve all syllables that contain five phonemes -->
<!-- query(ae, "[Num(Syllable, Phoneme) == 5]") -->
<!-- @ -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- \subsection{More complex queries} -->
<!-- \label{subsec:query_moreComplexQueries} -->

<!-- By using the correct bracketing, all of the above query components can be combined to formulate more complex queries that can be used to answer questions such as: \textit{Which occurrences of the word \textit{``his''} follow three-syllable words which contain a schwa (\textit{@}) in the first syllable?} Such multi-part questions can usually be broken down into several sub-queries. These sub-queries can then be recombined to formulate the complex query. The steps to answering the above multi-part question are: -->

<!-- \begin{enumerate} -->
<!--   \item \textit{Which occurrences of the word \textit{``his''} ...}: \texttt{[Text == his]} -->
<!--   \item \textit{... three-syllable words ...}: \texttt{[Num(Text, Syllable) == 3]} -->
<!--   \item \textit{... contain a schwa (\textit{@}) in the first syllable ...}: \texttt{[Phoneme == @ \textasciicircum{} Start(Word, Syllable) == 1]} -->
<!--   \item All three can be combined by saying 2 dominates 3 (\texttt{[2 \textasciicircum{} 3]}) and these are followed by 1 (\texttt{[2 \textasciicircum 3] -> 1]}) -->
<!-- \end{enumerate} -->

<!-- The combine query is depicted in R Example \ref{rexample:query_moreComplexQuery}. This complex query demonstrates the expressive power of the query mechanism that the EMU-SDMS provides. -->

<!-- <<rexample:query_moreComplexQuery, rexample=TRUE>>= -->
<!-- # perform complex query -->
<!-- # Note that the use of paste0() is optional, as -->
<!-- # it is only used for formatting purposes -->
<!-- query(ae, paste0("[[[Num(Text, Syllable) == 3] ", -->
<!--                  "^ [Phoneme == @ ^ Start(Word, Syllable) == 1]] ", -->
<!--                  "-> #Text = his]")) -->
<!-- @ -->

<!-- As mastering these complex compound queries can require some practice, several simple as well as more complex examples that combine the various \ac{eql} components described above are available in Appendix \ref{app_chap:eql}. These examples provide practical examples to help users in find queries suited to their needs. -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- \subsection{Deducing time} -->
<!-- \label{subsec:query_deducingTime} -->

<!-- The default behavior of the legacy EMU system was to automatically deduce time information for queries of levels that do not contain time information. This was achieved by searching for the time-bearing sub-level and calculating the start and end times from the left-most and right-most annotation items, which where directly or indirectly linked to the retrieved parent item. This upward purculation of time information is also the default behavior of the new \ac{emu-sdms}. However, a new feature has been added to the query engine which allows the calculation of time to be switched off for a given query using the \texttt{calcTimes} parameter of the \texttt{query()} function. This is beneficial in two ways: for one, levels that do not have a time-bearing sub-level may be queried and secondly, the execution time of queries can be greatly improved. The performance increase becomes evident when performing queries on large data sets on one of the top levels of the hierarchy (e.g., \textit{Utterance} or \textit{Intonational} in the \textit{ae} \texttt{emuDB}). When deducing time information for annotation items that contain large portions of the hierarchy, the query engine has to walk down large partial hierarchies to find the left-most and right-most items on the time-bearing sub-level. This can be a computationally expensive operation and is often unnecessary, especially during data exploration. R Example \ref{rexample:query_deducingTime} shows the usage of this parameter by querying all of the items of the \textit{Intonational} level and displaying the \texttt{NA} values for start and end times in the resulting segment list. It is worth noting that the missing time information excluded during the original query can be retrieved at a later point in time by performing a hierarchical requery (see Section \ref{subsec:requery}) on the same level. -->

<!-- <<rexample:query_deducingTime, rexample=TRUE>>= -->
<!-- # query all intonational items -->
<!-- sl = query(ae, "Intonational =~ .*", calcTimes = F) -->

<!--  # show first entry of sl -->
<!-- head(sl, n = 1) -->
<!-- @ -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- \subsection{Requery} -->
<!-- \label{subsec:requery} -->

<!-- A popular feature of the legacy system was the ability to use the result of a query to perform an additional query, called a requery, starting from the resulting items of a query. The requery functionality was used to move either sequentially (horizontally) or hierarchically (vertically) through the hierarchical annotation structure. Although this feature technically does not extend the querying functionality (it is possible to formulate \ac{eql} queries that yield the same results as a query followed by $1:n$ requeries), requeries benefit the user by breaking down the task of formulating long query terms into multiple, simpler queries. Compared with the legacy system, this feature is implemented in the \texttt{emuR} package in a more robust way, as unique item IDs are present in the result of a query, eliminating the need for searching the starting segments based on their time information. Examples of queries and their results within a hierarchical annotation based on a hierarchical and sequential requery as well as their \ac{eql} equivalents are illustrated in Figure \ref{fig:query_requery}. -->

<!-- \begin{figure}[hpt] -->
<!-- \centering -->
<!--   \input{pics/requery} -->
<!--   \caption{Three-step (\textcolor{three_color_c1}{query} $\rightarrow$ \textcolor{three_color_c2}{requery\_hier} $\rightarrow$ \textcolor{three_color_c3}{requery\_seq}) requery procedure, its single \textcolor{darkgray}{query} counterpart and their color coded movements within the annotation hierarchy.} -->
<!--   \label{fig:query_requery} -->
<!-- \end{figure} -->

<!-- R Example \ref{rexample:query_requery} illustrates how the same results of the sequential query \texttt{[\#Phonetic =\textasciitilde .* -> Phonetic == n]} can be achieved using the \texttt{requery\_seq()} function. Further, it shows how the \texttt{requery\_hier()} function can be used to move vertically through the annotation structure by starting at the \textit{Syllable} level and retrieving all the \textit{Phonetic} items for the query result. -->


<!-- <<rexample:query_requery, rexample=TRUE>>= -->
<!-- ######################## -->
<!-- # requery_seq() -->

<!-- # query all "n" phonetic items -->
<!-- sl_n = query(ae, "Phonetic == n") -->

<!-- # sequential requery (left shift result by 1 (== offset of -1)) -->
<!-- # and hence retrieve all phonetic items directly preceeding  -->
<!-- # all "n" phonetic items -->
<!-- sl_precn = requery_seq(ae, seglist = sl_n, offset = -1) -->

<!-- # show first entry of sl_precn -->
<!-- head(sl_precn, n = 1)  -->

<!-- ######################## -->
<!-- # requery_hier() -->

<!-- # query all strong syllables (S) -->
<!-- sl_s = query(ae, "Syllable == S") -->

<!-- # hierarchical requery  -->
<!-- sl_phonetic = requery_hier(ae, seglist = sl_s,  -->
<!--                            level = "Phonetic") -->

<!-- # show first entry of sl_phonetic -->
<!-- head(sl_phonetic, n = 1)  -->
<!-- @ -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- \section{Discussion} -->

<!-- This chapter gave an overview of the abilities of the query system of the \ac{emu-sdms}. We feel the \ac{eql} is an expressive, powerful, yet simple to learn and domain-specific query language that allows users to adequately query complex annotation structures. Further, the query system provided by the \ac{emu-sdms} surpasses the querying capabilities of most commonly used systems. As the result of a query is a superclass of the common \texttt{data.frame} object, these results can easily be further processed using various R functions (e.g., to remove unwanted segments). Further, the results of queries can be used as input to the \texttt{get\_trackdata()} function (see Chapter \ref{chap:sigDataExtr}) which makes the query system a vital part in the default workflow described in Chapter \ref{chap:overview}. -->

<!-- Although the query mechanism of the \ac{emu-sdms} covers most linguistic annotation query needs (including co-occurrence and domination relationship child position queries), it has limitations due to its domain-specific nature, its simplicity and its predefined result type. Performing more general queries such as: \textit{What is the average age of the male speakers in the database who are taller than 1.8 meters?} is not directly possible using the \ac{eql}. Even if the gender, height and age parameters are available as part of the database's annotations (e.g., using the single bundle root node metadata strategy described in Chapter \ref{chap:annot_struct_mod}) they would be encoded as strings, which do not permit direct calculations or numerical comparisons. However, it is possible to answer these types of questions using a multi-step approach. One could, for example, extract all height items and convert the strings into numbers to filter the items containing a label that is greater than 1.8. These filtered items could then be used to perform two requeries to extract all male speakers and their age labels. These age labels could once again be converted into numbers to calculate their average. Although not as elegant as other languages, we have found that most questions that arise as part of studies working with spoken language database can be answered using such a multi-step process including some data manipulation in R, provided the necessary information is encoded in the database. Additionally, from the viewpoint of a speech scientist, we feel that the intuitiveness of an \ac{eql} expression (e.g., a query to extract the sibilant items for the question asked in the introduction: \texttt{"Phonetic == s|z|S|Z"}) exceeds that of a comparable general purpose query language (e.g. a semantically similar \ac{sql} statement: \texttt{SELECT desired\_columns FROM items AS i, labels AS l WHERE i.unique\_bundle\_item\_id = l.uniq\_bundle\_item\_id AND l.label = `s' OR l.label = `z' OR l.label = `s' OR l.label = `S' OR l.label = `Z'}). This difference becomes even more apparent with more complex \ac{eql} statements, which can have very long, complicated and sometimes multi-expression \ac{sql} counterparts. -->

<!-- A problem which the \ac{emu-sdms} does not explicitly address is the problem of cross-corpus searches. Different \texttt{emuDB}s may have varying annotation structures with varying semantics regarding the names or labels given to objects or annotation items in the databases. This means that it is very likely that a complex query formulated for a certain \texttt{emuDB} will fail when used to query other databases. If, however, the user either finds a query that works on every \texttt{emuDB} or adapts the query to extract the items she/he is interested in, a cross-corpus comparison is simple. As the result of a query and the corresponding data extraction routines are the same, regardless of database they where extracted from, these results are easily comparable. However, it is worth noting that the \ac{emu-sdms} is completely indifferent to the semantics of labels and level names, which means it is the user's responsibility to check if a comparison between databases is justifiable (e.g., \textit{are all segments containing the label ``@'' of the level ``Phonetic'' in all \texttt{emuDB}s annotating the same type of phoneme?}). -->

<!-- <<echo=FALSE, results='hide', message=FALSE>>= -->
<!-- # clean up emuR_demoData -->
<!-- unlink(file.path(tempdir(), "emuR_demoData"), recursive = TRUE) -->
<!-- @ -->

