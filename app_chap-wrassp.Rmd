# `wrassp` {#app-chap:wrassp}

## Using Praat's signal processing routines in the EMU-SDMS {#sec:app-chap-wrassp-praatsSigProc}

### `To Formant (burg)` to SSFF files

The R code snippet below shows how to generate `AsspDataObj` objects from scratch and place data from other sources into SSFF files. The snippet uses [speakr](https://stefanocoretta.github.io/speakr/), an R package to run Praat scripts from within R. The function `praat2AsspDataObj()` runs a Praat script (generated by `write_praat_script()`) that executes a Praat command on a given sound file, either `To Formant (burg)` or `To Pitch`. The `Formant` and `PitchTier` objects created with these commands is then converted to a comma-separated table with `Down to Table` and `Down to PitchTier` respectively. The generated table/tier is then read into R and the appropriate columns are placed into tracks of a `AsspDataObj` object. The `Praat2AsspDataObj` can be viewed as a template function as it can be adapted to use other functions provided by Praat or even other external tools.

**NOTE**. These functions can be sourced into your R session directly with:

```{r eval=F}
source("https://raw.githubusercontent.com/IPS-LMU/The-EMU-SDMS-Manual/master/R/praat2AsspDataObj.R")
```

```{r, eval=F, code=readLines("R/praat2AsspDataObj.R")}
```

The following code chunk shows how this function can be applied to `.wav` files of an emuDB.

```{r, eval=F, message=F}
library(emuR)

# create demo data in tempdir()
create_emuRdemoData(tempdir())

# create path to demo database
path2ae = file.path(tempdir(), "emuR_demoData", "ae_emuDB")

# list all .wav files in the ae emuDB
paths2wavFiles = list.files(path2ae, pattern = "*.wav$",
                            recursive = TRUE, full.names = TRUE)

# loop through files
## formants
for(fp in paths2wavFiles){
  ado = praat2AsspDataObj(fp, object = "formant")
  newPath = paste0(tools::file_path_sans_ext(fp), '.praatFms')
  # print(paste0(fp, ' -> ', newPath)) # uncomment for simple log
  wrassp::write.AsspDataObj(ado, file = newPath)
}
## pitch
for(fp in paths2wavFiles){
  ado = praat2AsspDataObj(fp,
                          object = "pitch",
                          time_step = 0.00625,
                          pitch_floor = 60,
                          smooth = TRUE)
  newPath = paste0(tools::file_path_sans_ext(fp), '.praatF0')
  # print(paste0(fp, ' -> ', newPath)) # uncomment for simple log
  wrassp::write.AsspDataObj(ado, file = newPath)
}

# load emuDB
# (verbose = F is only set to avoid additional output in manual)
ae = load_emuDB(path2ae, verbose = FALSE)

# add SSFF track definition
add_ssffTrackDefinition(ae,
                        name = "praatFms",
                        columnName = "fm",
                        fileExtension = "praatFms")

add_ssffTrackDefinition(ae,
                        name = "praatF0",
                        columnName = "f0",
                        fileExtension = "praatF0")

# test query + get_trackdata
sl = query(ae, "Phonetic == n")

# (verbose = F is only set to avoid additional output in manual)
td = get_trackdata(ae,
                   sl,
                   ssffTrackName = "praatFms",
                   verbose = F)

pt = get_trackdata(ae,
                   sl,
                   ssffTrackName = "praatF0",
                   verbose = F)
```

```{r echo=FALSE, results='hide', message=FALSE}
# clean up emuR_demoData
unlink(file.path(tempdir(), "emuR_demoData"), recursive = TRUE)
```


A few comments about synchronized F0 and Formant values:

- **The `time_step` argument is "Time step (s) (standard value: 0.0) the measurement interval (frame duration), in seconds.**
If you supply 0, Praat will use a time step of 0.75 / (pitch floor), e.g. 0.01 seconds if the pitch floor is 75 Hz;
in this example, Praat computes 100 pitch values per second. "
Here `time_step` is set to 0.00625 (Seconds) when calculating pitch (as opposed to Praat's default of 0.0) in order
to keep it in line with Time step in "To Formant...",
because Time step in "To Formants..." is derived from
window length (which in "To Formant..." defaults to 0.025) (window length/4 (--> Time step in "To Formant..."
will usually be 0.00625))
- **The `pitch_floor` argument is "Pitch floor (Hz) (standard value: 75 Hz)**:
candidates below this frequency will not be recruited.
This parameter determines the length of the analysis window: it will be 3 longest periods long, i.e.,
if the pitch floor is 75 Hz, the window will be 3/75 = 0.04 seconds long.
Note that if you set the time step to zero, the analysis windows for consecutive measurements will overlap appreciably:
Praat will always compute 4 pitch values within one window length, i.e., the degree of oversampling is 4."
Importantly, this parameter is set NOT to praat's default 75 Hz, but to 60 Hz, again because of correspondence
of window lengths between "To Pitch..." and "To Formants...". The actual window length in "To Formants..." will be twice as long
as the value given in the "To Formants..." command, i.e. the default of 0.025 will result in a window length of 0.05.
A window length in "To Pitch..." can indirectly achieved by using a pitch floor value of 60 Hz (given that 3/60 = 0.05).
In most cases, differing window lengths will not affect the temporal position of the F0 and Formant values, however, due
to problems near the edges, sometimes they will (and therefore result in non-synchronized F0 and Formant values).
Due to rounding errors, F0 and Formant values still might be slightly asynchronous; to avoid this, `praat2AsspDataObj()`
rounds the start time with a precicion of 0.001 ms (via `round(attr(ado, "startTime"),6)` at the very end).
- **The `pitch_ceiling` argument (default: 600)** will not affect any of the other parameters.



## Using OpenSMILE signal processing routines in the EMU-SDMS {#sec:app-chap-wrassp-opensmileSigProc}

NOTE: this function can be accessed directly as follows: `source("https://raw.githubusercontent.com/IPS-LMU/The-EMU-SDMS-Manual/master/R/SMILExtract2AsspDataObj.R")`

```{r, eval=FALSE, code=readLines("R/SMILExtract2AsspDataObj.R")}
```

How this function can be applied to wav files of an emuDB is shown below.

```{r, eval=F, message=F}
library(emuR)

# create demo data in tempdir()
create_emuRdemoData(tempdir())

# create path to demo database
path2ae = file.path(tempdir(), "emuR_demoData", "ae_emuDB")

# list all .wav files in the ae emuDB
paths2wavFiles = list.files(path2ae,
                            pattern = "*.wav$",
                            recursive = TRUE,
                            full.names = TRUE)

# loop through files
for(fp in paths2wavFiles){
  ado = SMILExtract2AsspDataObj(fp,
                                SMILExtractPath = "~/programs/opensmile-2.3.0/bin/SMILExtract",
                                configPath = "~/programs/opensmile-2.3.0/config/demo/demo1_energy.conf")
  newPath = paste0(file_path_sans_ext(fp), '.SMILExtract')
  # print(paste0(fp, ' -> ', newPath)) # uncomment for simple log
  write.AsspDataObj(ado, file = newPath)
}

# load emuDB
# (verbose = F is only set to avoid additional output in manual)
ae = load_emuDB(path2ae, verbose = FALSE)

# add SSFF track definition
add_ssffTrackDefinition(ae,
                        name = "SMILExtract",
                        columnName = "pcm_LOGenergy",
                        fileExtension = "SMILExtract")

# test query + get_trackdata
sl = query(ae, "Phonetic == n")
# (verbose = F is only set to avoid additional output in manual)
td = get_trackdata(ae,
                   sl,
                   ssffTrackName = "SMILExtract",
                   verbose = F)

# test display
set_signalCanvasesOrder(ae,
                        perspectiveName = "default",
                        order = c("OSCI", "SPEC", "SMILExtract"))

# serve(ae) # uncomment to view in EMU-webApp
```

```{r echo=FALSE, results='hide', message=FALSE}
# clean up emuR_demoData
unlink(file.path(tempdir(), "emuR_demoData"), recursive = TRUE)
```

